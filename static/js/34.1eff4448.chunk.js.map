{"version":3,"sources":["views/Nft/market/index.tsx","state/nftMarket/hooks.ts"],"names":["Home","lazy","NftProfile","Collection","Collections","Market","account","useWeb3React","initializationState","useGetNFTInitializationState","useFetchCollections","NFTMarketInitializationState","INITIALIZED","exact","path","nftsBaseUrl","to","pancakeBunniesAddress","toLowerCase","dispatch","useAppDispatch","useEffect","fetchCollections","useFetchCollection","collectionAddress","fetchCollection","useFetchByBunnyIdAndUpdate","bunnyId","useSelector","state","nftMarket","data","loadingState","latestPancakeBunniesUpdateAt","isUpdatingPancakeBunnies","existingBunniesInState","useGetAllBunniesByBunnyId","existingTokensWithBunnyId","map","nft","tokenId","allPancakeBunnies","useNftsFromCollection","allExistingPBTokenIds","firstBunny","length","existingMetadata","useMemo","name","description","collection","collectionName","image","fetchMorePancakeBunnies","orderDirection","fetchNewPBAndUpdateExisting","useLoadingState","useGetCollections","collections","useGetCollection","checksummedCollectionAddress","isAddress","nfts","filter","attributes","value","marketData","isTradable","useUserNfts","user","useHasGen0Nfts","some","Number"],"mappings":"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","file":"static/js/34.1eff4448.chunk.js","sourcesContent":["import React, { lazy } from 'react'\nimport { Redirect, Route } from 'react-router-dom'\nimport { useWeb3React } from '@web3-react/core'\nimport { useFetchCollections, useGetNFTInitializationState } from 'state/nftMarket/hooks'\nimport PageLoader from 'components/Loader/PageLoader'\nimport { NFTMarketInitializationState } from 'state/nftMarket/types'\nimport { nftsBaseUrl, pancakeBunniesAddress } from './constants'\n\nconst Home = lazy(() => import('./Home'))\nconst NftProfile = lazy(() => import('./Profile'))\nconst Collection = lazy(() => import('./Collection'))\nconst Collections = lazy(() => import('./Collections'))\n\nconst Market = () => {\n  const { account } = useWeb3React()\n  const initializationState = useGetNFTInitializationState()\n\n  useFetchCollections()\n\n  if (initializationState !== NFTMarketInitializationState.INITIALIZED) {\n    return <PageLoader />\n  }\n\n  return (\n    <>\n      <Route exact path={nftsBaseUrl}>\n        <Home />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/collections`}>\n        <Redirect to={`${nftsBaseUrl}/collections/${pancakeBunniesAddress}`} />\n        <Collections />\n      </Route>\n      <Route path={`${nftsBaseUrl}/collections/:collectionAddress`}>\n        <Collection />\n      </Route>\n      <Route path={`${nftsBaseUrl}/profile/:accountAddress?`}>\n        <NftProfile />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/profile`}>\n        <Redirect to={`${nftsBaseUrl}/profile/${account?.toLowerCase() || ''}`} />\n      </Route>\n    </>\n  )\n}\n\nexport default Market\n","import { useEffect, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from 'state'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport { isAddress } from 'utils'\nimport { fetchCollection, fetchCollections, fetchNewPBAndUpdateExisting } from './reducer'\nimport { State } from '../types'\nimport { NftToken, UserNftsState } from './types'\n\nconst MAX_GEN0_ID = 4\n\nexport const useFetchCollections = () => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollections())\n  }, [dispatch])\n}\n\nexport const useFetchCollection = (collectionAddress: string) => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollection(collectionAddress))\n  }, [dispatch, collectionAddress])\n}\n\n// Returns a function that fetches more NFTs for specified bunny id\n// as well as updating existing PB NFTs in state\n// Note: PancakeBunny specific\nexport const useFetchByBunnyIdAndUpdate = (bunnyId: string) => {\n  const dispatch = useAppDispatch()\n\n  const { latestPancakeBunniesUpdateAt, isUpdatingPancakeBunnies } = useSelector(\n    (state: State) => state.nftMarket.data.loadingState,\n  )\n\n  // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId)\n  const existingTokensWithBunnyId = existingBunniesInState ? existingBunniesInState.map((nft) => nft.tokenId) : []\n\n  const allPancakeBunnies = useNftsFromCollection(pancakeBunniesAddress)\n  const allExistingPBTokenIds = allPancakeBunnies ? allPancakeBunnies.map((nft) => nft.tokenId) : []\n\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null\n\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n  const existingMetadata = useMemo(() => {\n    return firstBunny\n      ? {\n          name: firstBunny.name,\n          description: firstBunny.description,\n          collection: { name: firstBunny.collectionName },\n          image: firstBunny.image,\n        }\n      : null\n  }, [firstBunny])\n\n  // This fetches more bunnies when called\n  const fetchMorePancakeBunnies = (orderDirection: 'asc' | 'desc') => {\n    dispatch(\n      fetchNewPBAndUpdateExisting({\n        bunnyId,\n        existingTokensWithBunnyId,\n        allExistingPBTokenIds,\n        existingMetadata,\n        orderDirection,\n      }),\n    )\n  }\n\n  return { isUpdatingPancakeBunnies, latestPancakeBunniesUpdateAt, fetchMorePancakeBunnies }\n}\n\nexport const useLoadingState = () => {\n  return useSelector((state: State) => state.nftMarket.data.loadingState)\n}\n\nexport const useGetCollections = () => {\n  return useSelector((state: State) => state.nftMarket.data.collections)\n}\n\nexport const useGetCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const collections = useGetCollections()\n  return collections[checksummedCollectionAddress]\n}\n\nexport const useNftsFromCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\n  return nfts\n}\n\nexport const useGetAllBunniesByBunnyId = (bunnyId: string) => {\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[pancakeBunniesAddress])\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\n}\n\nexport const useGetNFTInitializationState = () => {\n  return useSelector((state: State) => state.nftMarket.initializationState)\n}\n\nexport const useUserNfts = (): UserNftsState => {\n  return useSelector((state: State) => state.nftMarket.data.user)\n}\n\nexport const useHasGen0Nfts = (): boolean => {\n  const userNfts = useSelector((state: State) => state.nftMarket.data.user)\n  return userNfts.nfts.some((nft) => nft.attributes && Number(nft.attributes[0]?.value) <= MAX_GEN0_ID)\n}\n"],"sourceRoot":""}